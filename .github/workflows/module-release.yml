# Copyright (c) Adaptive Technology
# SPDX-License-Identifier: Apache-2.0

name: Module Release

on:
  push:
    branches: [main]
    paths:
      - 'aws/**/*.tf'
      - 'aws/**/*.hcl'
      - 'cloudflare/**/*.tf'
      - 'cloudflare/**/*.hcl'
      - '!**/*.md'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., v1.0.0)'
        required: true
        type: string
      release_type:
        description: 'Release type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
          - prerelease
      prerelease_suffix:
        description: 'Prerelease suffix (e.g., rc.1, beta.1)'
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write
  id-token: write

# env values will be loaded from SSM parameters

jobs:
  test-modules:
    name: Test Modules
    runs-on: ubuntu-latest
    strategy:
      matrix:
        module:
          - aws/vpc/foundation
          - aws/vpc/security
          - aws/vpc/operations
          - aws/security/certificates/ssm-acm
          - aws/networking/ram-tagging
          - cloudflare/zero-trust
          - aws/compute/ec2-cloudflared
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # Bootstrap authentication: role ARN is stored in AWS_OIDC_ROLE_SECOPS environment secret for centralized management.
          # All other configuration values are then loaded dynamically from SSM Parameter Store.
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_SECOPS }}
          role-session-name: github-actions-${{ github.run_id }}
          aws-region: us-east-1

      - name: Load Configuration from SSM
        id: load-config
        run: |
          set -euo pipefail
          echo "Loading CI/CD configuration from SSM..."
          if ! OPENTOFU_VERSION=$(aws ssm get-parameter \
            --name "/worx/common/ci/opentofu-version" \
            --query 'Parameter.Value' \
            --output text \
            --region us-east-1 2>/dev/null); then
            echo "::error::Failed to read /worx/common/ci/opentofu-version from SSM" >&2
            exit 1
          fi

          if [ -z "$OPENTOFU_VERSION" ] || [ "$OPENTOFU_VERSION" = "None" ]; then
            echo "::error::SSM parameter /worx/common/ci/opentofu-version is empty" >&2
            exit 1
          fi

          echo "OPENTOFU_VERSION=$OPENTOFU_VERSION" >> "$GITHUB_ENV"
          echo "Loaded OpenTofu version: $OPENTOFU_VERSION"

      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.OPENTOFU_VERSION }}

      - name: Validate Module - ${{ matrix.module }}
        working-directory: ${{ matrix.module }}
        run: |
          echo "🔍 Validating module: ${{ matrix.module }}"
          
          # Initialize without backend
          tofu init -backend=false
          
          # Validate configuration
          tofu validate
          
          # Format check
          tofu fmt -check=true -diff
          
          echo "✅ Module validation passed"

      - name: Security Scan - ${{ matrix.module }}
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: ${{ matrix.module }}
          soft_fail: true

  determine-version:
    name: Determine Version
    runs-on: ubuntu-latest
    needs: test-modules
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      should_release: ${{ steps.version.outputs.should_release }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest tag
        id: latest_tag
        run: |
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$latest_tag" >> $GITHUB_OUTPUT
          echo "Latest tag: $latest_tag"

      - name: Calculate new version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual release with specified version
            new_version="${{ github.event.inputs.version }}"
            
            # Add prerelease suffix if specified
            if [ -n "${{ github.event.inputs.prerelease_suffix }}" ]; then
              new_version="${new_version}-${{ github.event.inputs.prerelease_suffix }}"
            fi
            
            should_release="true"
          else
            # Automatic versioning based on commit messages
            latest_tag="${{ steps.latest_tag.outputs.latest_tag }}"
            
            # Parse current version
            current_version=${latest_tag#v}
            IFS='.' read -r major minor patch <<< "${current_version%-*}"
            
            # Check commit messages for version bump indicators
            commits=$(git log ${latest_tag}..HEAD --pretty=format:"%s")
            
            if echo "$commits" | grep -q "BREAKING CHANGE:\|feat!:\|fix!:"; then
              # Major version bump
              major=$((major + 1))
              minor=0
              patch=0
              echo "Detected breaking change - major version bump"
            elif echo "$commits" | grep -q "^feat:"; then
              # Minor version bump
              minor=$((minor + 1))
              patch=0
              echo "Detected new feature - minor version bump"
            elif echo "$commits" | grep -q "^fix:\|^chore:\|^docs:"; then
              # Patch version bump
              patch=$((patch + 1))
              echo "Detected fix/chore - patch version bump"
            else
              echo "No version bump needed"
              should_release="false"
              new_version=""
            fi
            
            if [ "$should_release" != "false" ]; then
              new_version="v${major}.${minor}.${patch}"
              should_release="true"
            fi
          fi
          
          echo "new_version=$new_version" >> $GITHUB_OUTPUT
          echo "should_release=$should_release" >> $GITHUB_OUTPUT
          echo "New version: $new_version (release: $should_release)"

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: determine-version
    if: needs.determine-version.outputs.should_release == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Release Notes
        id: release_notes
        run: |
          new_version="${{ needs.determine-version.outputs.new_version }}"
          
          # Get commit history since last tag
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -n "$latest_tag" ]; then
            commits=$(git log ${latest_tag}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          else
            commits=$(git log --pretty=format:"- %s (%h)" --no-merges)
          fi
          
          # Generate release notes
          cat > release_notes.md << EOF
          ## 🚀 Module Release ${new_version}
          
          ### 📦 What's Changed
          
          ${commits}
          
          ### 📋 Module Versions
          
          All modules in this repository are now available at version ${new_version}.
          
          ### 🔧 Usage
          
          Update your \`module-versions.hcl\` file to use this version:
          
          \`\`\`hcl
          module_versions = {
            your_environment = {
              vpc_foundation = "ref=${new_version}"
              # ... other modules
            }
          }
          \`\`\`
          
          ### 📚 Documentation
          
          See individual module README files for detailed usage instructions.
          
          ---
          
          *This release was automatically generated based on commit history.*
          EOF
          
          echo "Release notes generated"

      - name: Create Git Tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          new_version="${{ needs.determine-version.outputs.new_version }}"
          git tag -a "$new_version" -m "Release $new_version"
          git push origin "$new_version"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.determine-version.outputs.new_version }}
          name: ${{ needs.determine-version.outputs.new_version }}
          body_path: release_notes.md
          draft: false
          prerelease: ${{ contains(needs.determine-version.outputs.new_version, '-') }}

  notify-consumers:
    name: Notify Consumers
    runs-on: ubuntu-latest
    needs: [determine-version, create-release]
    if: needs.determine-version.outputs.should_release == 'true'
    steps:
      - name: Trigger iac-worx workflows
        uses: peter-evans/repository-dispatch@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: AdaptiveWorX/iac-worx
          event-type: module-release
          client-payload: '{"version": "${{ needs.determine-version.outputs.new_version }}", "repository": "iac-modules"}'

      - name: Summary
        run: |
          echo "## 📦 Module Release Summary"
          echo ""
          echo "**Version:** ${{ needs.determine-version.outputs.new_version }}"
          echo "**Status:** ✅ Successfully released"
          echo ""
          echo "### Next Steps"
          echo "1. Update \`module-versions.hcl\` in iac-worx repository"
          echo "2. Test new version in development environment"
          echo "3. Progressively roll out to staging and production"
          echo ""
          echo "---"
          echo "*Modules are now available for consumption at the new version.*"
